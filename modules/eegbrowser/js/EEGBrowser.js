!function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={exports:{},id:moduleId,loaded:!1};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.loaded=!0,module.exports}var installedModules={};return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.p="",__webpack_require__(0)}({0:function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function makeRegions(numRegions){for(var regions=[],i=0;i<numRegions;i+=1){var center=new Array(3).fill(0).map(function(){return 2*Math.random()-1}),region=new Region("region"+i,"Region "+i,center);regions.push(region)}return regions}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_react=__webpack_require__(15),_react2=_interopRequireDefault(_react),_MRILoader=__webpack_require__(16),_MRILoader2=_interopRequireDefault(_MRILoader),NUM_REGIONS=8,POINTS_PER_REGION=5,SAMPLES_PER_POINT=200,Region=function(){function Region(name,label,center){_classCallCheck(this,Region),this.name=name,this.label=label,this.points=[],this.generatePoints(POINTS_PER_REGION,center)}return _createClass(Region,[{key:"generatePoints",value:function(numPoints,center){for(var i=0;i<numPoints;i+=1){var point=new Array(3).fill(0).map(function(){return(2*Math.random()-1)/NUM_REGIONS});point[0]+=center[0],point[1]+=center[1],point[2]+=center[2],this.points.push(new Point(point,SAMPLES_PER_POINT))}}}]),Region}(),Point=function Point(position,timeSamples){var _this=this,tmin=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,tmax=arguments.length>3&&void 0!==arguments[3]?arguments[3]:60;_classCallCheck(this,Point),this.tmin=tmin,this.tmax=tmax,this.domain=new Float32Array(timeSamples).fill(0),this.domain.forEach(function(_,i){var t=i/timeSamples;_this.domain[i]=tmin*(1-t)+tmax*t}),this.signal=new Float32Array(timeSamples).fill(0),this.signal.forEach(function(_,i){_this.signal[i]=2*Math.random()-1}),this.position=position,this.hovered=!1},RegionSelect=function(_Component){function RegionSelect(props){_classCallCheck(this,RegionSelect);var _this2=_possibleConstructorReturn(this,(RegionSelect.__proto__||Object.getPrototypeOf(RegionSelect)).call(this,props));return _this2.defaultProps={regions:[],selected:[]},_this2}return _inherits(RegionSelect,_Component),_createClass(RegionSelect,[{key:"render",value:function(){var _this3=this,regionElement=function(region,selected,onclick){return _react2.default.createElement("li",{key:region.name,className:"region-item "+(selected?"selected-region":"unselected-region"),onClick:function(){return onclick(region)},onMouseEnter:function(){_this3.props.hoverRegion(region)},onMouseLeave:function(){_this3.props.hoverRegion(region)}},region.label+(selected?"*":""))},regionElements=this.props.regions.map(function(region){return _this3.props.selected.find(function(r){return r===region})?regionElement(region,!0,_this3.props.unselectRegion):regionElement(region,!1,_this3.props.selectRegion)});return _react2.default.createElement("div",{className:"region-select"},_react2.default.createElement("ul",{className:"region-select-list"},regionElements))}}]),RegionSelect}(_react.Component),YELLOW=16737832,GREEN=3450963,BLUE=4359668,MRIView=function(_Component2){function MRIView(){return _classCallCheck(this,MRIView),_possibleConstructorReturn(this,(MRIView.__proto__||Object.getPrototypeOf(MRIView)).apply(this,arguments))}return _inherits(MRIView,_Component2),_createClass(MRIView,[{key:"componentDidMount",value:function(){var _this5=this,_canvas$getBoundingCl=this.canvas.getBoundingClientRect(),width=_canvas$getBoundingCl.width,height=_canvas$getBoundingCl.height,renderer=new THREE.WebGLRenderer({canvas:this.canvas});renderer.setSize(width,height),this.camera=new THREE.PerspectiveCamera(45,width/height,1,1e3),this.controls=new THREE.OrbitControls(this.camera,this.canvas),this.scene=new THREE.Scene,this.mriLoader=new _MRILoader2.default(this.scene),this.mriLoader.initialize().then(function(dimensions){function run(){renderer.render(self.scene,self.camera),window.requestAnimationFrame(run.bind(self))}var scale=dimensions.scale/2;_this5.camera.position.z=-dimensions.diagonal/1.5,_this5.camera.lookAt(new THREE.Vector3(0,0,0)),_this5.meshes=[];var material=new THREE.MeshBasicMaterial({color:YELLOW}),geometry=new THREE.SphereBufferGeometry(dimensions.scale/(10*NUM_REGIONS),8,8);_this5.props.regions.forEach(function(region,i){region.points.forEach(function(point){var mesh=new THREE.Mesh(geometry,new THREE.MeshBasicMaterial);mesh.material.copy(material),mesh.position.fromArray(point.position),mesh.position.multiplyScalar(scale),_this5.scene.add(mesh),_this5.meshes[i]||(_this5.meshes[i]=[]),_this5.meshes[i].push(mesh)})});var self=_this5;run()})}},{key:"componentDidUpdate",value:function(){var _this6=this;this.props.regions.forEach(function(region,i){region.points.forEach(function(point){_this6.meshes[i].forEach(function(m){m.material.color.setHex(YELLOW)}),_this6.props.selected.find(function(r){return r===region})&&_this6.meshes[i].forEach(function(m){m.material.color.setHex(GREEN)}),_this6.props.hoveredRegion===region&&_this6.meshes[i].forEach(function(m){m.material.color.setHex(BLUE)})})})}},{key:"render",value:function(){var _this7=this;return _react2.default.createElement("div",{className:"mri-view-container"},_react2.default.createElement("canvas",{className:"mri-view",width:"450",height:"400",ref:function(canvas){_this7.canvas=canvas}}))}}]),MRIView}(_react.Component),SignalPlots=function(_Component3){function SignalPlots(){return _classCallCheck(this,SignalPlots),_possibleConstructorReturn(this,(SignalPlots.__proto__||Object.getPrototypeOf(SignalPlots)).apply(this,arguments))}return _inherits(SignalPlots,_Component3),_createClass(SignalPlots,[{key:"componentDidMount",value:function(){this.renderPlots()}},{key:"componentDidUpdate",value:function(){this.renderPlots()}},{key:"renderPlots",value:function(){var _this9=this,WIDTH=400,HEIGHT=200;d3.select(this.container).selectAll("svg").remove(),this.props.selected.forEach(function(region){region.points.forEach(function(point){var tmin=point.tmin,tmax=point.tmax,idx=point.domain.map(function(_,i){return i}),x=d3.scale.linear().domain([tmin,tmax]).rangeRound([0,WIDTH]),y=d3.scale.linear().domain([-2,2]).rangeRound([HEIGHT/1.6,0]),line=d3.svg.line().x(function(i){return x(point.domain[i])}).y(function(i){return y(point.signal[i])}),g=d3.select(_this9.container).append("div").attr("class","signal-plot-item").append("svg").attr("width",WIDTH).attr("height",HEIGHT).append("g").attr("transform","translate(60, 10)"),xAxis=d3.svg.axis().scale(x).ticks(20).orient("bottom"),yAxis=d3.svg.axis().scale(y).ticks(5).orient("left");g.append("g").call(xAxis).attr("transform","translate(0.2, "+(HEIGHT/2+25)+")"),g.append("g").call(yAxis),g.selectAll(".domain").attr("fill","none").attr("stroke","black").attr("stroke-width",1.5),g.append("path").attr("fill","none").attr("stroke","steelblue").attr("stroke-linejoin","round").attr("stroke-linecap","round").attr("stroke-width",1.5).attr("d",line(idx))})})}},{key:"render",value:function(){var _this10=this;return _react2.default.createElement("div",{className:"signal-plots",ref:function(container){_this10.container=container}})}}]),SignalPlots}(_react.Component),EEGBrowser=function(_Component4){function EEGBrowser(props){_classCallCheck(this,EEGBrowser);var _this11=_possibleConstructorReturn(this,(EEGBrowser.__proto__||Object.getPrototypeOf(EEGBrowser)).call(this,props));return _this11.state={regions:makeRegions(NUM_REGIONS),selected:[]},_this11}return _inherits(EEGBrowser,_Component4),_createClass(EEGBrowser,[{key:"render",value:function(){var _this12=this,unselectRegion=function(region){_this12.setState({selected:_this12.state.selected.filter(function(r){return r!==region})})},selectRegion=function(region){_this12.setState({selected:_this12.state.selected.filter(function(r){return r!==region}).concat([region])})};return _react2.default.createElement("div",{className:"eeg-browser"},_react2.default.createElement(RegionSelect,{regions:this.state.regions,selected:this.state.selected,unselectRegion:unselectRegion,selectRegion:selectRegion,hoverRegion:function(region){_this12.setState({hoveredRegion:region})},onMouseLeave:function(){_this12.setState({hoveredRegion:null})}}),_react2.default.createElement(MRIView,{regions:this.state.regions,selected:this.state.selected,hoveredRegion:this.state.hoveredRegion}),_react2.default.createElement(SignalPlots,{selected:this.state.selected}))}}]),EEGBrowser}(_react.Component);exports.default=EEGBrowser,window.EEGBrowser=_react2.default.createFactory(EEGBrowser)},15:function(module,exports){module.exports=React},16:function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Shaders=__webpack_require__(17),MRI_URL="/eegbrowser/static/full8_400um_optbal.mnc",MRILoader=function(){function MRILoader(scene){_classCallCheck(this,MRILoader),this.scene=scene}return _createClass(MRILoader,[{key:"initialize",value:function(){var sliceMatrixSize={},spaceLength={},url2buf=new pixpipe.UrlToArrayBufferReader;new pixpipe.FileToArrayBufferReader;url2buf.addInput(MRI_URL),url2buf.update();var self=this;return new Promise(function(resolve){url2buf.on("ready",function(){var buffer=this.getOutput(),genericDecoder=new pixpipe.Image3DGenericDecoder;if(genericDecoder.addInput(buffer),genericDecoder.update(),!genericDecoder.getNumberOfOutputs())return void console.warn("No output from generic decoder.");var mniVolume=genericDecoder.getOutput();if(mniVolume){var mosaicFilter=new pixpipe.Image3DToMosaicFilter;mosaicFilter.addInput(mniVolume);var space="zspace";if(mosaicFilter.setMetadata("axis",space),mosaicFilter.setMetadata("time",-1),mosaicFilter.update(),!mosaicFilter.getNumberOfOutputs())return void console.warn("No output for mosaicFilter.");for(var textures=[],nbOut=0;nbOut<mosaicFilter.getNumberOfOutputs();nbOut++){var outputMosaic=mosaicFilter.getOutput(nbOut);console.log(outputMosaic),outputMosaic.setMetadata("min",mniVolume.getMetadata("voxel_min")),outputMosaic.setMetadata("max",mniVolume.getMetadata("voxel_max"));var data=outputMosaic.getDataAsUInt8Array(),texture=new THREE.DataTexture(data,outputMosaic.getWidth(),outputMosaic.getHeight(),THREE.LuminanceFormat,THREE.UnsignedByteType);texture.needsUpdate=!0,textures.push(texture)}sliceMatrixSize.x=mosaicFilter.getMetadata("gridWidth"),sliceMatrixSize.y=mosaicFilter.getMetadata("gridHeight"),spaceLength.x=mniVolume.getMetadata("xspace").space_length,spaceLength.y=mniVolume.getMetadata("yspace").space_length,spaceLength.z=mniVolume.getMetadata("zspace").space_length,spaceLength.t=mniVolume.getTimeLength(),this.textures=textures,this.sliceMatrixSize=sliceMatrixSize,this.spaceLength=spaceLength;var diagonal=2*Math.sqrt(spaceLength.x*spaceLength.x+spaceLength.y*spaceLength.y+spaceLength.z*spaceLength.z),scale=Math.min(spaceLength.x,spaceLength.y,spaceLength.z);return self.createMRIPlanes({textures:textures,sliceMatrixSize:sliceMatrixSize,spaceLength:spaceLength}),void resolve({diagonal:diagonal,scale:scale})}console.warn("Non-existant output for genericDecoder."),resolve({diagonal:1,scale:1})})})}},{key:"getDimensions",value:function(){}},{key:"getShaderMaterial",value:function(){return this.shaderMaterial}},{key:"createMRIPlanes",value:function(params){var textures=params.textures,sliceMatrixSize=params.sliceMatrixSize,spaceLength=params.spaceLength,system=new THREE.Object3D;this.shaderMaterial=new THREE.ShaderMaterial({uniforms:{nbOfTextureUsed:{type:"i",value:textures.length},nbSlicePerRow:{type:"f",value:sliceMatrixSize.x},nbSlicePerCol:{type:"f",value:sliceMatrixSize.y},nbSliceTotal:{type:"f",value:spaceLength.z},xspaceLength:{type:"f",value:spaceLength.x},yspaceLength:{type:"f",value:spaceLength.y},zspaceLength:{type:"f",value:spaceLength.z},timespaceLength:{type:"i",value:spaceLength.t},timeIndex:{type:"i",value:0},forcedAlpha:{type:"f",value:1},textures:{type:"t",value:textures},trilinearInterpol:{type:"b",value:!1},curveTexture:{type:"t",value:null},enableCurve:{type:"b",value:!1}},vertexShader:_Shaders.VERTEX,fragmentShader:_Shaders.FRAGMENT,side:THREE.DoubleSide,transparent:!0});var largestSide=2*Math.sqrt(spaceLength.x*spaceLength.x+spaceLength.y*spaceLength.y+spaceLength.z*spaceLength.z),zPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),zPlaneMesh=new THREE.Mesh(zPlaneGeometry,this.shaderMaterial);system.add(zPlaneMesh);var xPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),xPlaneMesh=new THREE.Mesh(xPlaneGeometry,this.shaderMaterial);xPlaneMesh.rotation.y=Math.PI/2,system.add(xPlaneMesh);var zPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),zPlaneMesh=new THREE.Mesh(zPlaneGeometry,this.shaderMaterial);zPlaneMesh.rotation.x=Math.PI/2,system.add(zPlaneMesh),this.scene.add(system)}}]),MRILoader}();exports.default=MRILoader},17:function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.VERTEX="\n  precision highp float;\n  varying  vec2 vUv;\n  varying  vec4 worldCoord;\n  void main()\n  {\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n    worldCoord = modelMatrix * vec4( position, 1.0 );\n  }\n",exports.FRAGMENT="\n  precision highp float;\n  // a max number we allow, can be upt to 16\n  const int maxNbOfTextures = 15;\n  // Number of texture used with this dataset\n  // cannot be higher than maxNbOfTextures\n  uniform int nbOfTextureUsed;\n  // size of the mosaic\n  uniform float nbSlicePerRow;\n  uniform float nbSlicePerCol;\n  // not necessary equal to nbSlicePerRow*nbSlicePerCol because last line\n  // is not necessary full\n  uniform float nbSliceTotal;\n  // space length\n  uniform float xspaceLength;\n  uniform float yspaceLength;\n  uniform float zspaceLength;\n  uniform int timespaceLength;\n  // the index within the timeseries\n  uniform int timeIndex;\n  uniform float forcedAlpha;\n  // a texture will contain a certain number of slices\n  uniform sampler2D textures[maxNbOfTextures];\n  // enabling the trilinear interpolation\n  uniform bool trilinearInterpol;\n  // texture that represent the curve data to look up\n  uniform sampler2D curveTexture;\n  // enable contrast curve\n  uniform bool enableCurve;\n  // Shared with the vertex shader\n  varying  vec4 worldCoord;\n  varying  vec2 vUv;\n  /**\n  * Returns accurate MOD when arguments are approximate integers.\n  */\n  float modI(float a,float b) {\n      float m = a - floor( ( a + 0.0001 ) / b) * b;\n      return floor( m + 0.0001 );\n  }\n  // return the color corresponding to the given shifted world cooridinates\n  // using a neirest neighbors approx (no interpolation)\n  vec4 getIntensityWorldNearest(vec3 swc, int timeRecord){\n    // step to jump from a slice to another on a unit-sized texture\n    float sliceWidth = 1.0 / nbSlicePerRow;\n    float sliceHeight = 1.0 / nbSlicePerCol;\n    float rounder = 0.001;\n    // to be kept\n    float indexSliceToDisplay = floor( float(timeRecord) * zspaceLength   + swc.z + rounder);\n    int indexTextureInUse = int(floor(rounder + indexSliceToDisplay / (nbSlicePerRow*nbSlicePerCol)));\n    float rowTextureAbsolute = floor( (indexSliceToDisplay + rounder) / nbSlicePerRow);\n    float rowTexture = rowTextureAbsolute - (float(indexTextureInUse) * nbSlicePerCol) ;\n    float colTexture = modI( indexSliceToDisplay, nbSlicePerRow );\n    // switch to a center-pixel reference (shift of half a pixel in unit-sized texture)\n    float halpPixH = sliceWidth / xspaceLength / 2.0;\n    float halpPixV = sliceHeight / yspaceLength / 2.0;\n    // avoid being exactely between 2 slices because it can produce unpredictable result (stripes)\n    if(mod(swc.x, 0.5) == 0.0){\n      swc.x -= rounder;\n    }\n    // avoid being exactely between 2 slices because it can produce unpredictable result (stripes)\n    if(mod(swc.y, 0.5) == 0.0){\n      swc.y -= rounder;\n    }\n    // the actual textel 2D position of this 3D word coordinate\n    vec2 posInTexture = vec2(\n      sliceWidth * colTexture + ( swc.x/xspaceLength * sliceWidth) + halpPixH,\n      sliceHeight * rowTexture + (1.0 / nbSlicePerCol  - swc.y/yspaceLength * sliceHeight) + halpPixV\n    );\n    vec4 color;\n    // fetching the color in the texture (loops are not allowed)\n    if(indexTextureInUse == 0){\n      color = texture2D(textures[0], posInTexture);\n    }else if(indexTextureInUse == 1){\n      color = texture2D(textures[1], posInTexture);\n    }else if(indexTextureInUse == 2){\n      color = texture2D(textures[2], posInTexture);\n    }else if(indexTextureInUse == 3){\n      color = texture2D(textures[3], posInTexture);\n    }else if(indexTextureInUse == 4){\n      color = texture2D(textures[4], posInTexture);\n    }else if(indexTextureInUse == 5){\n      color = texture2D(textures[5], posInTexture);\n    }else if(indexTextureInUse == 6){\n      color = texture2D(textures[6], posInTexture);\n    }else if(indexTextureInUse == 7){\n      color = texture2D(textures[7], posInTexture);\n    }else if(indexTextureInUse == 8){\n      color = texture2D(textures[8], posInTexture);\n    }else if(indexTextureInUse == 9){\n      color = texture2D(textures[9], posInTexture);\n    }else if(indexTextureInUse == 10){\n      color = texture2D(textures[10], posInTexture);\n    }else if(indexTextureInUse == 11){\n      color = texture2D(textures[11], posInTexture);\n    }else if(indexTextureInUse == 12){\n      color = texture2D(textures[12], posInTexture);\n    }else if(indexTextureInUse == 13){\n      color = texture2D(textures[13], posInTexture);\n    }else if(indexTextureInUse == 14){\n      color = texture2D(textures[14], posInTexture);\n    }/*else if(indexTextureInUse == 15){\n      color = texture2D(textures[15], posInTexture);\n    }else if(indexTextureInUse == 16){\n      color = texture2D(textures[16], posInTexture);\n    }else if(indexTextureInUse == 17){\n      color = texture2D(textures[17], posInTexture);\n    }else if(indexTextureInUse == 18){\n      color = texture2D(textures[18], posInTexture);\n    }else if(indexTextureInUse == 19){\n      color = texture2D(textures[19], posInTexture);\n    }else if(indexTextureInUse == 20){\n      color = texture2D(textures[20], posInTexture);\n    }else if(indexTextureInUse == 21){\n      color = texture2D(textures[21], posInTexture);\n    }else if(indexTextureInUse == 22){\n      color = texture2D(textures[22], posInTexture);\n    }else if(indexTextureInUse == 23){\n      color = texture2D(textures[23], posInTexture);\n    }else if(indexTextureInUse == 24){\n      color = texture2D(textures[24], posInTexture);\n    }else if(indexTextureInUse == 25){\n      color = texture2D(textures[25], posInTexture);\n    }*/\n    return color;\n  }\n  vec4 getIntensityWorldTrilinear( vec3 swc, int timeRecord ){\n    // For the sake of readability, let's assume that:\n    float xBottom = floor(swc.x + 0.05);\n    float yBottom = floor(swc.y + 0.05);\n    float zBottom = floor(swc.z + 0.05);\n    float xTop = floor(xBottom + 1.05);\n    float yTop = floor(yBottom + 1.05);\n    float zTop = floor(zBottom + 1.05);\n    // making a normalized space out of our coordinates\n    float xNorm = swc.x - xBottom;\n    float yNorm = swc.y - yBottom;\n    float zNorm = swc.z - zBottom;\n    // fetching the colors at each corner\n    vec4 V000 = getIntensityWorldNearest( vec3(xBottom, yBottom, zBottom), timeRecord );\n    vec4 V100 = getIntensityWorldNearest( vec3(xTop, yBottom, zBottom), timeRecord );\n    vec4 V010 = getIntensityWorldNearest( vec3(xBottom, yTop, zBottom), timeRecord );\n    vec4 V001 = getIntensityWorldNearest( vec3(xBottom, yBottom, zTop), timeRecord );\n    vec4 V101 = getIntensityWorldNearest( vec3(xTop, yBottom, zTop), timeRecord );\n    vec4 V011 = getIntensityWorldNearest( vec3(xBottom, yTop, zTop), timeRecord );\n    vec4 V110 = getIntensityWorldNearest( vec3(xTop, yTop, zBottom), timeRecord );\n    vec4 V111 = getIntensityWorldNearest( vec3(xTop, yTop, zTop), timeRecord );\n    vec4 interpVal = V000 * (1. - xNorm) * (1. - yNorm) * (1. - zNorm) +\n                     V100 * xNorm * (1. - yNorm) * (1. - zNorm) +\n                     V010 * (1. - xNorm) * yNorm * (1. - zNorm) +\n                     V001 * (1. - xNorm) * (1. - yNorm) * zNorm +\n                     V101 * xNorm * (1. - yNorm) * zNorm +\n                     V011 * (1. - xNorm) * yNorm * zNorm +\n                     V110 * xNorm * yNorm * (1. - zNorm) +\n                     V111 * xNorm * yNorm * zNorm;\n    return interpVal;\n  }\n  // return true id the shifted world cooridinates (swc) is outside the volume\n  // then we can hide what is ouside\n  bool isOusideTheVolume( vec3 swc ){\n    return swc.x < 0.0 || swc.x > xspaceLength ||\n           swc.y < 0.0 || swc.y > yspaceLength ||\n           swc.z < 0.0 || swc.z > zspaceLength;\n  }\n  // return true if the shifted world cooridinates (swc) is just on the internal\n  // edge. Then we can display a thin line for edges\n  bool isInternalEdge( vec3 swc ){\n    float edgeSize = 0.5;\n    return swc.x < edgeSize || swc.x > (xspaceLength - edgeSize) ||\n           swc.y < edgeSize || swc.y > (yspaceLength - edgeSize) ||\n           swc.z < edgeSize || swc.z > (zspaceLength - edgeSize);\n  }\n  void main( void ) {\n    // worldCoord is [0, n], but the box is centered on 0 to make rotation work better\n    // so worldCoordShifted is like worldCoord but shifted of half size in each direction\n    vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, worldCoord.y + yspaceLength/2.0, worldCoord.z + zspaceLength/2.0);\n\n    // This version makes the antero side up (default: down)\n    //vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, -1.0*worldCoord.y + yspaceLength/2.0, -1.0*worldCoord.z + zspaceLength/2.0);\n    //vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, worldCoord.y + yspaceLength/2.0, -1.0*worldCoord.z + zspaceLength/2.0);\n    // hide the outside\n    if( isOusideTheVolume(worldCoordShifted) )\n    {\n        discard;\n        return;\n    }\n    // color at the edges of the volume\n    if( isInternalEdge(worldCoordShifted) )\n    {\n        gl_FragColor = vec4(0.7, 0.7, 1.0, 1.0);\n        return;\n    }\n    vec4 color;\n    // interpolation (or not)\n    if(trilinearInterpol){\n      color = getIntensityWorldTrilinear(worldCoordShifted, timeIndex);\n    }else{\n      color = getIntensityWorldNearest(worldCoordShifted, timeIndex);\n    }\n    // use curve for contrast\n    if(enableCurve){\n      vec4 curveColor = texture2D(curveTexture, vec2(color.r, 0.5));\n      color.r = curveColor.r;\n      color.g = curveColor.g;\n      color.b = curveColor.b;\n    }\n    // forcing a lower alpha (when given)\n    color.a = min(color.a, forcedAlpha);\n    gl_FragColor = color;\n  }\n"}});
//# sourceMappingURL=EEGBrowser.js.map