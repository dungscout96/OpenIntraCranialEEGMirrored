!function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={exports:{},id:moduleId,loaded:!1};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.loaded=!0,module.exports}var installedModules={};return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.p="",__webpack_require__(0)}({0:function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _possibleConstructorReturn(self,call){if(!self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!=typeof call&&"function"!=typeof call?self:call}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}}),superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function makeRegions(numRegions){for(var regions=[],i=0;i<numRegions;i+=1){var center=new Array(3).fill(0).map(function(){return 2*Math.random()-1}),region=new Region("region"+i,"Region "+i,center);regions.push(region)}return regions}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_react=__webpack_require__(25),_react2=_interopRequireDefault(_react),_MRILoader=__webpack_require__(26),_MRILoader2=_interopRequireDefault(_MRILoader),NUM_REGIONS=8,POINTS_PER_REGION=30,SAMPLES_PER_POINT=500,Region=function(){function Region(name,label,center){_classCallCheck(this,Region),this.name=name,this.label=label,this.points=[],this.generatePoints(POINTS_PER_REGION,center)}return _createClass(Region,[{key:"generatePoints",value:function(numPoints,center){for(var i=0;i<numPoints;i+=1){var point=new Array(3).fill(0).map(function(){return(2*Math.random()-1)/NUM_REGIONS});point[0]+=center[0],point[1]+=center[1],point[2]+=center[2],this.points.push(new Point(point,SAMPLES_PER_POINT))}}}]),Region}(),Point=function Point(position,timeSamples){var _this=this,tmin=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,tmax=arguments.length>3&&void 0!==arguments[3]?arguments[3]:60;_classCallCheck(this,Point),this.tmin=tmin,this.tmax=tmax,this.domain=new Float32Array(timeSamples).fill(0),this.domain.forEach(function(_,i){var t=i/timeSamples;_this.domain[i]=tmin*(1-t)+tmax*t}),this.signal=new Float32Array(timeSamples).fill(0),this.signal.forEach(function(_,i){_this.signal[i]=2*Math.random()-1}),this.position=position,this.hovered=!1},RegionSelect=function(_Component){function RegionSelect(props){_classCallCheck(this,RegionSelect);var _this2=_possibleConstructorReturn(this,(RegionSelect.__proto__||Object.getPrototypeOf(RegionSelect)).call(this,props));return _this2.defaultProps={regions:[],selected:[]},_this2}return _inherits(RegionSelect,_Component),_createClass(RegionSelect,[{key:"render",value:function(){var _this3=this,regionElement=function(region,selected,onclick){return _react2.default.createElement("li",{key:region.name,className:"region-item "+(selected?"selected-region":"unselected-region"),onClick:function(){return onclick(region)},onMouseEnter:function(){_this3.props.hoverRegion(region)},onMouseLeave:function(){_this3.props.hoverRegion(region)}},region.label+(selected?"*":""))},regionElements=this.props.regions.map(function(region){return _this3.props.selected.find(function(r){return r===region})?regionElement(region,!0,_this3.props.unselectRegion):regionElement(region,!1,_this3.props.selectRegion)});return _react2.default.createElement("div",{className:"region-select"},_react2.default.createElement("ul",{className:"region-select-list"},regionElements))}}]),RegionSelect}(_react.Component),YELLOW=16737832,GREEN=3450963,BLUE=4359668,MRIView=function(_Component2){function MRIView(){return _classCallCheck(this,MRIView),_possibleConstructorReturn(this,(MRIView.__proto__||Object.getPrototypeOf(MRIView)).apply(this,arguments))}return _inherits(MRIView,_Component2),_createClass(MRIView,[{key:"componentDidMount",value:function(){var _this5=this,width=500,height=400,renderer=new THREE.WebGLRenderer;this.canvas=renderer.domElement,this.canvas.width=width,this.canvas.height=height,this.addCanvas(),renderer.setSize(width,height),this.camera=new THREE.PerspectiveCamera(45,width/height,1,1e3),this.controls=new THREE.OrbitControls(this.camera,this.canvas),this.scene=new THREE.Scene,this.mriLoader=new _MRILoader2.default(this.scene),this.meshes=[],this.mriLoader.initialize().then(function(dimensions){function run(){renderer.render(self.scene,self.camera),window.requestAnimationFrame(run.bind(self))}var scale=dimensions.scale/2;_this5.camera.position.z=-dimensions.diagonal/1.7,_this5.camera.lookAt(new THREE.Vector3(0,0,0));var material=new THREE.MeshBasicMaterial({color:YELLOW}),geometry=new THREE.SphereBufferGeometry(scale/(10*NUM_REGIONS),8,8);_this5.props.regions.forEach(function(region,i){region.points.forEach(function(point){var mesh=new THREE.Mesh(geometry,new THREE.MeshBasicMaterial);mesh.material.copy(material),mesh.position.fromArray(point.position),mesh.position.multiplyScalar(scale),_this5.scene.add(mesh),_this5.meshes[i]||(_this5.meshes[i]=[]),_this5.meshes[i].push(mesh)})});var self=_this5;run()})}},{key:"componentDidUpdate",value:function(){var _this6=this;this.addCanvas(),this.props.regions.forEach(function(region,i){region.points.forEach(function(point){_this6.meshes[i]&&(_this6.meshes[i].forEach(function(m){m.material.color.setHex(YELLOW)}),_this6.props.selected.find(function(r){return r===region})&&_this6.meshes[i].forEach(function(m){m.material.color.setHex(GREEN)}),_this6.props.hoveredRegion===region&&_this6.meshes[i].forEach(function(m){m.material.color.setHex(BLUE)}))})})}},{key:"addCanvas",value:function(){this.container&&this.lastContainer!==this.container&&(this.container.appendChild(this.canvas),this.lastContainer=this.container)}},{key:"render",value:function(){var _this7=this;return this.props.showMRI?_react2.default.createElement("div",{className:"mri-view-container",ref:function(div){_this7.container=div}}):null}}]),MRIView}(_react.Component),ZOOM_AMOUNT=1,INTERVAL_MOVE_AMOUNT=1,PLOTS_PER_PAGE=7,countNumPoints=function(regions){return regions.map(function(r){return r.points.length}).reduce(function(a,b){return a+b},0)},SignalPlots=function(_Component3){function SignalPlots(props){_classCallCheck(this,SignalPlots);var _this8=_possibleConstructorReturn(this,(SignalPlots.__proto__||Object.getPrototypeOf(SignalPlots)).call(this,props));return _this8.lastMouseX=null,_this8.drawn=[],_this8.state={bounds:{tmin:-.1,tmax:25},page:0},_this8}return _inherits(SignalPlots,_Component3),_createClass(SignalPlots,[{key:"componentWillReceiveProps",value:function(nextProps){var maxPage=Math.floor(countNumPoints(nextProps.selected)/PLOTS_PER_PAGE),newPage=this.state.page>maxPage?maxPage:this.state.page;this.setState({page:newPage})}},{key:"componentDidMount",value:function(){var _this9=this;window.addEventListener("mouseup",function(){_this9.lastMouseX=null}),window.addEventListener("resize",function(){_this9.forceUpdate()}),this.renderPlots()}},{key:"componentDidUpdate",value:function(){this.renderPlots()}},{key:"renderPlots",value:function(){var _this10=this;this.width=this.container.getBoundingClientRect().width-20;var HEIGHT=100,_state$bounds=this.state.bounds,tmin=_state$bounds.tmin,tmax=_state$bounds.tmax;this.xAxisTop&&(this.xAxisTop.remove(),this.xAxisTop=void 0),this.xAxisBottom&&(this.xAxisBottom.remove(),this.xAxisBottom=void 0);var x=d3.scale.linear().domain([tmin,tmax]).rangeRound([0,this.width]),y=d3.scale.linear().domain([-1.7,1.7]).rangeRound([HEIGHT,0]),yAxis=d3.svg.axis().scale(y).ticks(0).tickValues([-1,0,1]).outerTickSize(0).orient("left"),drawSignalLine=function(g,point,indexes){var signalLine=d3.svg.line().x(function(i){return x(point.domain[i]||0)}).y(function(i){return y(point.signal[i]||0)});return g.append("path").attr("fill","none").attr("stroke","steelblue").attr("stroke-linejoin","round").attr("stroke-linecap","round").attr("stroke-width",1.5).attr("d",signalLine(indexes))},drawSecondTicks=function(g,yAxis,tmin,tmax){for(var ctmin=Math.ceil(tmin),ctmax=Math.ceil(tmax),secondTicks=g.append("g"),_yAxis$node$getBoundi=yAxis.node().getBoundingClientRect(),height=_yAxis$node$getBoundi.height,t=ctmin;t<ctmax;t++)secondTicks.append("line").attr({x1:x(t),y1:0}).attr({x2:x(t),y2:height}).attr("stroke-width",1).attr("stroke","#999");return secondTicks},drawZeroLine=function(g,tmin,tmax){return g.append("line").attr({x1:x(tmin),y1:y(0)}).attr({x2:x(tmax),y2:y(0)}).attr("stroke-width",1).attr("stroke","#555")};this.drawn.forEach(function(drawn){drawn.tagged=!1}),this.drawn.length>0&&this.drawn[this.drawn.length-1].svg.attr("class","signal-plot-item");var numPoints=-1;this.props.selected.forEach(function(region){region.points.forEach(function(point){if(numPoints++,!(numPoints<(PLOTS_PER_PAGE-1)*_this10.state.page||numPoints>(PLOTS_PER_PAGE-1)*(_this10.state.page+1))){var indexFilter=function(indexes,t,i){return t>=tmin&&t<=tmax&&indexes.push(i),indexes},indexes=point.domain.reduce(indexFilter,[]),drawn=_this10.drawn.find(function(d){return d.point===point});if(drawn){var _g=drawn.g,_sigLine=drawn.sigLine,_secondTicks=drawn.secondTicks,_zeroLine=drawn.zeroLine,_yAx=drawn.yAx;return _sigLine.remove(),_secondTicks.remove(),_zeroLine.remove(),_yAx.call(yAxis),drawn.sigLine=drawSignalLine(_g,point,indexes),drawn.secondTicks=drawSecondTicks(_g,_yAx,tmin,tmax),drawn.zeroLine=drawZeroLine(_g,tmin,tmax),void(drawn.tagged=!0)}var svg=d3.select(_this10.container).append("svg").attr("class","signal-plot-item").attr("height",HEIGHT),g=svg.append("g").attr("transform","translate(30, 0)"),rect=g.append("rect").attr("width","100%"),yAx=g.append("g").call(yAxis),_yAx$node$getBounding=yAx.node().getBoundingClientRect(),height=_yAx$node$getBounding.height;rect.attr("height",height);var sigLine=drawSignalLine(g,point,indexes),secondTicks=drawSecondTicks(g,yAx,tmin,tmax),zeroLine=drawZeroLine(g,tmin,tmax);_this10.drawn.push({point:point,svg:svg,rect:rect,g:g,sigLine:sigLine,secondTicks:secondTicks,zeroLine:zeroLine,yAx:yAx,tagged:!0})}})}),this.drawn.forEach(function(drawn,i){drawn.tagged||drawn.svg.remove()}),this.drawn=this.drawn.filter(function(drawn){return drawn.tagged}),this.drawn.forEach(function(drawn,i){return i%2===1?void drawn.rect.attr("fill","#eee"):void drawn.rect.attr("fill","#fff")});var drawXaxis=function(orientation,drawn,xoffset,yoffset){var xAxis=d3.svg.axis().scale(x).ticks(10).outerTickSize(0).orient(orientation);return drawn.g.append("g").call(xAxis).attr("transform","translate("+xoffset+", "+yoffset+")")};this.drawn.length>0&&(this.xAxisTop=drawXaxis("bottom",this.drawn[0],0,0),this.xAxisBottom=drawXaxis("bottom",this.drawn[this.drawn.length-1],0,HEIGHT),this.drawn[this.drawn.length-1].svg.attr("class","signal-plot-item last-plot")),d3.select(this.container).selectAll(".domain").attr("fill","none").attr("stroke","black").attr("stroke-width",1.5)}},{key:"render",value:function(){var _this11=this,_onWheel=function(dy){var _state$bounds2=_this11.state.bounds,tmin=_state$bounds2.tmin,tmax=_state$bounds2.tmax;tmax-tmin<=5&&dy<0||tmax-tmin>=65&&dy>0||_this11.setState({bounds:{tmin:tmin-Math.sign(dy)*ZOOM_AMOUNT*(tmax-tmin)/15,tmax:tmax+Math.sign(dy)*ZOOM_AMOUNT*(tmax-tmin)/15}})},_onMouseMove=function(dx){if(_this11.lastMouseX){var width=_this11.width||1,_state$bounds3=_this11.state.bounds,tmin=_state$bounds3.tmin,tmax=_state$bounds3.tmax;_this11.lastMouseX+=dx,_this11.setState({bounds:{tmin:tmin-dx*INTERVAL_MOVE_AMOUNT*(tmax-tmin)/width,tmax:tmax-dx*INTERVAL_MOVE_AMOUNT*(tmax-tmin)/width}})}},enabled=function(text,incr){return _react2.default.createElement("div",{className:"signal-plots-button",onClick:function(){_this11.setState({page:_this11.state.page+incr})}},text)},disabled=function(text){return _react2.default.createElement("div",{className:"signal-plots-button disabled"},text)},numPoints=countNumPoints(this.props.selected),showNext=this.state.page<Math.floor(numPoints/PLOTS_PER_PAGE),showPrev=this.state.page>0;return _react2.default.createElement("div",{className:"signal-plots-container"},_react2.default.createElement("div",{className:"signal-plots-buttons"},showPrev?enabled("Previous",-1):disabled("Previous"),showNext?enabled("Next",1):disabled("Next"),_react2.default.createElement("div",{className:"signal-plots-page-number"},"Page: ",this.state.page+1)),_react2.default.createElement("div",{className:"signal-plots",ref:function(container){_this11.container=container},onWheel:function(e){e.shiftKey&&(e.preventDefault(),_onWheel(e.deltaY))},onMouseDown:function(e){0===e.button&&(_this11.lastMouseX=e.clientX)},onMouseMove:function(e){_onMouseMove(e.clientX-_this11.lastMouseX)}}))}}]),SignalPlots}(_react.Component),EEGBrowser=function(_Component4){function EEGBrowser(props){_classCallCheck(this,EEGBrowser);var _this12=_possibleConstructorReturn(this,(EEGBrowser.__proto__||Object.getPrototypeOf(EEGBrowser)).call(this,props)),regions=makeRegions(NUM_REGIONS);return _this12.state={regions:regions,selected:[regions[0]],expanded:!1},_this12}return _inherits(EEGBrowser,_Component4),_createClass(EEGBrowser,[{key:"render",value:function(){var _this13=this,unselectRegion=function(region){_this13.setState({selected:_this13.state.selected.filter(function(r){return r!==region})})},selectRegion=function(region){_this13.setState({selected:_this13.state.selected.filter(function(r){return r!==region}).concat([region])})},expandBar=_react2.default.createElement("div",{className:"expand-bar",onClick:function(){return _this13.setState({expanded:!_this13.state.expanded})}},_react2.default.createElement("span",{className:"expand-bar-icon"},this.state.expanded?">":"<")),regionSelect=_react2.default.createElement(RegionSelect,{regions:this.state.regions,selected:this.state.selected,unselectRegion:unselectRegion,selectRegion:selectRegion,hoverRegion:function(region){_this13.setState({hoveredRegion:region})},onMouseLeave:function(){_this13.setState({hoveredRegion:null})}}),mriView=_react2.default.createElement(MRIView,{regions:this.state.regions,selected:this.state.selected,hoveredRegion:this.state.hoveredRegion,showMRI:!this.state.expanded});return _react2.default.createElement("div",{className:"eeg-browser"},this.state.expanded?null:regionSelect,mriView,expandBar,_react2.default.createElement(SignalPlots,{selected:this.state.selected}))}}]),EEGBrowser}(_react.Component);exports.default=EEGBrowser,window.EEGBrowser=_react2.default.createFactory(EEGBrowser)},25:function(module,exports){module.exports=React},26:function(module,exports,__webpack_require__){"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_Shaders=__webpack_require__(27),MRI_URL="/eegbrowser/static/samir_mri.mnc",MRILoader=function(){function MRILoader(scene){_classCallCheck(this,MRILoader),this.scene=scene}return _createClass(MRILoader,[{key:"initialize",value:function(){var sliceMatrixSize={},spaceLength={},url2buf=new pixpipe.UrlToArrayBufferReader;new pixpipe.FileToArrayBufferReader;url2buf.addInput(MRI_URL),url2buf.update();var self=this;return new Promise(function(resolve){url2buf.on("ready",function(){var buffer=this.getOutput(),genericDecoder=new pixpipe.Image3DGenericDecoder;if(genericDecoder.addInput(buffer),genericDecoder.update(),!genericDecoder.getNumberOfOutputs())return void console.warn("No output from generic decoder.");var mniVolume=genericDecoder.getOutput();if(mniVolume){var mosaicFilter=new pixpipe.Image3DToMosaicFilter;mosaicFilter.addInput(mniVolume);var space="zspace";if(mosaicFilter.setMetadata("axis",space),mosaicFilter.setMetadata("time",-1),mosaicFilter.update(),!mosaicFilter.getNumberOfOutputs())return void console.warn("No output for mosaicFilter.");for(var textures=[],nbOut=0;nbOut<mosaicFilter.getNumberOfOutputs();nbOut++){var outputMosaic=mosaicFilter.getOutput(nbOut);console.log(outputMosaic),outputMosaic.setMetadata("min",mniVolume.getMetadata("voxel_min")),outputMosaic.setMetadata("max",mniVolume.getMetadata("voxel_max"));var data=outputMosaic.getDataAsUInt8Array(),texture=new THREE.DataTexture(data,outputMosaic.getWidth(),outputMosaic.getHeight(),THREE.LuminanceFormat,THREE.UnsignedByteType);texture.needsUpdate=!0,textures.push(texture)}sliceMatrixSize.x=mosaicFilter.getMetadata("gridWidth"),sliceMatrixSize.y=mosaicFilter.getMetadata("gridHeight"),spaceLength.x=mniVolume.getMetadata("xspace").space_length,spaceLength.y=mniVolume.getMetadata("yspace").space_length,spaceLength.z=mniVolume.getMetadata("zspace").space_length,spaceLength.t=mniVolume.getTimeLength(),this.textures=textures,this.sliceMatrixSize=sliceMatrixSize,this.spaceLength=spaceLength;var diagonal=2*Math.sqrt(spaceLength.x*spaceLength.x+spaceLength.y*spaceLength.y+spaceLength.z*spaceLength.z),scale=Math.min(spaceLength.x,spaceLength.y,spaceLength.z);return self.createMRIPlanes({textures:textures,sliceMatrixSize:sliceMatrixSize,spaceLength:spaceLength}),void resolve({diagonal:diagonal,scale:scale})}console.warn("Non-existant output for genericDecoder."),resolve({diagonal:1,scale:1})})})}},{key:"getDimensions",value:function(){}},{key:"getShaderMaterial",value:function(){return this.shaderMaterial}},{key:"createMRIPlanes",value:function(params){var textures=params.textures,sliceMatrixSize=params.sliceMatrixSize,spaceLength=params.spaceLength,system=new THREE.Object3D;this.shaderMaterial=new THREE.ShaderMaterial({uniforms:{nbOfTextureUsed:{type:"i",value:textures.length},nbSlicePerRow:{type:"f",value:sliceMatrixSize.x},nbSlicePerCol:{type:"f",value:sliceMatrixSize.y},nbSliceTotal:{type:"f",value:spaceLength.z},xspaceLength:{type:"f",value:spaceLength.x},yspaceLength:{type:"f",value:spaceLength.y},zspaceLength:{type:"f",value:spaceLength.z},timespaceLength:{type:"i",value:spaceLength.t},timeIndex:{type:"i",value:0},forcedAlpha:{type:"f",value:1},textures:{type:"t",value:textures},trilinearInterpol:{type:"b",value:!1},curveTexture:{type:"t",value:null},enableCurve:{type:"b",value:!1}},vertexShader:_Shaders.VERTEX,fragmentShader:_Shaders.FRAGMENT,side:THREE.DoubleSide,transparent:!0});var largestSide=2*Math.sqrt(spaceLength.x*spaceLength.x+spaceLength.y*spaceLength.y+spaceLength.z*spaceLength.z),zPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),zPlaneMesh=new THREE.Mesh(zPlaneGeometry,this.shaderMaterial);system.add(zPlaneMesh);var xPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),xPlaneMesh=new THREE.Mesh(xPlaneGeometry,this.shaderMaterial);xPlaneMesh.rotation.y=Math.PI/2,system.add(xPlaneMesh);var zPlaneGeometry=new THREE.PlaneBufferGeometry(largestSide,largestSide,1),zPlaneMesh=new THREE.Mesh(zPlaneGeometry,this.shaderMaterial);zPlaneMesh.rotation.x=Math.PI/2,system.add(zPlaneMesh),this.scene.add(system)}}]),MRILoader}();exports.default=MRILoader},27:function(module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.VERTEX="\n  precision highp float;\n  varying  vec2 vUv;\n  varying  vec4 worldCoord;\n  void main()\n  {\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n    worldCoord = modelMatrix * vec4( position, 1.0 );\n  }\n",exports.FRAGMENT="\n  precision highp float;\n  // a max number we allow, can be upt to 16\n  const int maxNbOfTextures = 15;\n  // Number of texture used with this dataset\n  // cannot be higher than maxNbOfTextures\n  uniform int nbOfTextureUsed;\n  // size of the mosaic\n  uniform float nbSlicePerRow;\n  uniform float nbSlicePerCol;\n  // not necessary equal to nbSlicePerRow*nbSlicePerCol because last line\n  // is not necessary full\n  uniform float nbSliceTotal;\n  // space length\n  uniform float xspaceLength;\n  uniform float yspaceLength;\n  uniform float zspaceLength;\n  uniform int timespaceLength;\n  // the index within the timeseries\n  uniform int timeIndex;\n  uniform float forcedAlpha;\n  // a texture will contain a certain number of slices\n  uniform sampler2D textures[maxNbOfTextures];\n  // enabling the trilinear interpolation\n  uniform bool trilinearInterpol;\n  // texture that represent the curve data to look up\n  uniform sampler2D curveTexture;\n  // enable contrast curve\n  uniform bool enableCurve;\n  // Shared with the vertex shader\n  varying  vec4 worldCoord;\n  varying  vec2 vUv;\n  /**\n  * Returns accurate MOD when arguments are approximate integers.\n  */\n  float modI(float a,float b) {\n      float m = a - floor( ( a + 0.0001 ) / b) * b;\n      return floor( m + 0.0001 );\n  }\n  // return the color corresponding to the given shifted world cooridinates\n  // using a neirest neighbors approx (no interpolation)\n  vec4 getIntensityWorldNearest(vec3 swcin, int timeRecord){\n    vec3 swc = swcin.xzy;\n    // step to jump from a slice to another on a unit-sized texture\n    float sliceWidth = 1.0 / nbSlicePerRow;\n    float sliceHeight = 1.0 / nbSlicePerCol;\n    float rounder = 0.001;\n    // to be kept\n    float indexSliceToDisplay = floor( float(timeRecord) * zspaceLength   + swc.z + rounder);\n    int indexTextureInUse = int(floor(rounder + indexSliceToDisplay / (nbSlicePerRow*nbSlicePerCol)));\n    float rowTextureAbsolute = floor( (indexSliceToDisplay + rounder) / nbSlicePerRow);\n    float rowTexture = rowTextureAbsolute - (float(indexTextureInUse) * nbSlicePerCol) ;\n    float colTexture = modI( indexSliceToDisplay, nbSlicePerRow );\n    // switch to a center-pixel reference (shift of half a pixel in unit-sized texture)\n    float halpPixH = sliceWidth / xspaceLength / 2.0;\n    float halpPixV = sliceHeight / yspaceLength / 2.0;\n    // avoid being exactely between 2 slices because it can produce unpredictable result (stripes)\n    if(mod(swc.x, 0.5) == 0.0){\n      swc.x -= rounder;\n    }\n    // avoid being exactely between 2 slices because it can produce unpredictable result (stripes)\n    if(mod(swc.y, 0.5) == 0.0){\n      swc.y -= rounder;\n    }\n    // the actual textel 2D position of this 3D word coordinate\n    vec2 posInTexture = vec2(\n      sliceWidth * colTexture + ( swc.x/xspaceLength * sliceWidth) + halpPixH,\n      sliceHeight * rowTexture + (1.0 / nbSlicePerCol  - swc.y/yspaceLength * sliceHeight) + halpPixV\n    );\n    vec4 color;\n    // fetching the color in the texture (loops are not allowed)\n    if(indexTextureInUse == 0){\n      color = texture2D(textures[0], posInTexture);\n    }else if(indexTextureInUse == 1){\n      color = texture2D(textures[1], posInTexture);\n    }else if(indexTextureInUse == 2){\n      color = texture2D(textures[2], posInTexture);\n    }else if(indexTextureInUse == 3){\n      color = texture2D(textures[3], posInTexture);\n    }else if(indexTextureInUse == 4){\n      color = texture2D(textures[4], posInTexture);\n    }else if(indexTextureInUse == 5){\n      color = texture2D(textures[5], posInTexture);\n    }else if(indexTextureInUse == 6){\n      color = texture2D(textures[6], posInTexture);\n    }else if(indexTextureInUse == 7){\n      color = texture2D(textures[7], posInTexture);\n    }else if(indexTextureInUse == 8){\n      color = texture2D(textures[8], posInTexture);\n    }else if(indexTextureInUse == 9){\n      color = texture2D(textures[9], posInTexture);\n    }else if(indexTextureInUse == 10){\n      color = texture2D(textures[10], posInTexture);\n    }else if(indexTextureInUse == 11){\n      color = texture2D(textures[11], posInTexture);\n    }else if(indexTextureInUse == 12){\n      color = texture2D(textures[12], posInTexture);\n    }else if(indexTextureInUse == 13){\n      color = texture2D(textures[13], posInTexture);\n    }else if(indexTextureInUse == 14){\n      color = texture2D(textures[14], posInTexture);\n    }/*else if(indexTextureInUse == 15){\n      color = texture2D(textures[15], posInTexture);\n    }else if(indexTextureInUse == 16){\n      color = texture2D(textures[16], posInTexture);\n    }else if(indexTextureInUse == 17){\n      color = texture2D(textures[17], posInTexture);\n    }else if(indexTextureInUse == 18){\n      color = texture2D(textures[18], posInTexture);\n    }else if(indexTextureInUse == 19){\n      color = texture2D(textures[19], posInTexture);\n    }else if(indexTextureInUse == 20){\n      color = texture2D(textures[20], posInTexture);\n    }else if(indexTextureInUse == 21){\n      color = texture2D(textures[21], posInTexture);\n    }else if(indexTextureInUse == 22){\n      color = texture2D(textures[22], posInTexture);\n    }else if(indexTextureInUse == 23){\n      color = texture2D(textures[23], posInTexture);\n    }else if(indexTextureInUse == 24){\n      color = texture2D(textures[24], posInTexture);\n    }else if(indexTextureInUse == 25){\n      color = texture2D(textures[25], posInTexture);\n    }*/\n    return color;\n  }\n  vec4 getIntensityWorldTrilinear( vec3 swc, int timeRecord ){\n    // For the sake of readability, let's assume that:\n    float xBottom = floor(swc.x + 0.05);\n    float yBottom = floor(swc.y + 0.05);\n    float zBottom = floor(swc.z + 0.05);\n    float xTop = floor(xBottom + 1.05);\n    float yTop = floor(yBottom + 1.05);\n    float zTop = floor(zBottom + 1.05);\n    // making a normalized space out of our coordinates\n    float xNorm = swc.x - xBottom;\n    float yNorm = swc.y - yBottom;\n    float zNorm = swc.z - zBottom;\n    // fetching the colors at each corner\n    vec4 V000 = getIntensityWorldNearest( vec3(xBottom, yBottom, zBottom), timeRecord );\n    vec4 V100 = getIntensityWorldNearest( vec3(xTop, yBottom, zBottom), timeRecord );\n    vec4 V010 = getIntensityWorldNearest( vec3(xBottom, yTop, zBottom), timeRecord );\n    vec4 V001 = getIntensityWorldNearest( vec3(xBottom, yBottom, zTop), timeRecord );\n    vec4 V101 = getIntensityWorldNearest( vec3(xTop, yBottom, zTop), timeRecord );\n    vec4 V011 = getIntensityWorldNearest( vec3(xBottom, yTop, zTop), timeRecord );\n    vec4 V110 = getIntensityWorldNearest( vec3(xTop, yTop, zBottom), timeRecord );\n    vec4 V111 = getIntensityWorldNearest( vec3(xTop, yTop, zTop), timeRecord );\n    vec4 interpVal = V000 * (1. - xNorm) * (1. - yNorm) * (1. - zNorm) +\n                     V100 * xNorm * (1. - yNorm) * (1. - zNorm) +\n                     V010 * (1. - xNorm) * yNorm * (1. - zNorm) +\n                     V001 * (1. - xNorm) * (1. - yNorm) * zNorm +\n                     V101 * xNorm * (1. - yNorm) * zNorm +\n                     V011 * (1. - xNorm) * yNorm * zNorm +\n                     V110 * xNorm * yNorm * (1. - zNorm) +\n                     V111 * xNorm * yNorm * zNorm;\n    return interpVal;\n  }\n  // return true id the shifted world cooridinates (swc) is outside the volume\n  // then we can hide what is ouside\n  bool isOusideTheVolume( vec3 swc ){\n    return swc.x < 0.0 || swc.x > xspaceLength ||\n           swc.y < 0.0 || swc.y > yspaceLength ||\n           swc.z < 0.0 || swc.z > zspaceLength;\n  }\n  // return true if the shifted world cooridinates (swc) is just on the internal\n  // edge. Then we can display a thin line for edges\n  bool isInternalEdge( vec3 swc ){\n    float edgeSize = 0.5;\n    return swc.x < edgeSize || swc.x > (xspaceLength - edgeSize) ||\n           swc.y < edgeSize || swc.y > (yspaceLength - edgeSize) ||\n           swc.z < edgeSize || swc.z > (zspaceLength - edgeSize);\n  }\n  void main( void ) {\n    // worldCoord is [0, n], but the box is centered on 0 to make rotation work better\n    // so worldCoordShifted is like worldCoord but shifted of half size in each direction\n    vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, worldCoord.y + yspaceLength/2.0, worldCoord.z + zspaceLength/2.0);\n\n    // This version makes the antero side up (default: down)\n    //vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, -1.0*worldCoord.y + yspaceLength/2.0, -1.0*worldCoord.z + zspaceLength/2.0);\n    //vec3 worldCoordShifted = vec3( worldCoord.x + xspaceLength/2.0, worldCoord.y + yspaceLength/2.0, -1.0*worldCoord.z + zspaceLength/2.0);\n    // hide the outside\n    if( isOusideTheVolume(worldCoordShifted) )\n    {\n        discard;\n        return;\n    }\n    // color at the edges of the volume\n    if( isInternalEdge(worldCoordShifted) )\n    {\n        gl_FragColor = vec4(0.7, 0.7, 1.0, 1.0);\n        return;\n    }\n    vec4 color;\n    // interpolation (or not)\n    if(trilinearInterpol){\n      color = getIntensityWorldTrilinear(worldCoordShifted, timeIndex);\n    }else{\n      color = getIntensityWorldNearest(worldCoordShifted, timeIndex);\n    }\n    // use curve for contrast\n    if(enableCurve){\n      vec4 curveColor = texture2D(curveTexture, vec2(color.r, 0.5));\n      color.r = curveColor.r;\n      color.g = curveColor.g;\n      color.b = curveColor.b;\n    }\n    // forcing a lower alpha (when given)\n    color.a = min(color.a, forcedAlpha);\n    gl_FragColor = color;\n  }\n"}});
//# sourceMappingURL=EEGBrowser.js.map